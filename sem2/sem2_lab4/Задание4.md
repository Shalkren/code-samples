#  Задание 4
Данная работа направлена на разработку деревьев поиска Binary Search Tree (BST)
В рамках данной работы вам предстоит выполнить следующие задания:
- [ ] Определите свой вариант **N**, чтобы выполнить задание ниже
- [ ] Попробуйте графическую визуализацию любого дерева, какого вам нужно на сайте cs.usfca.edu, для этого напишите <вид дерева> tree visualisation в поисковике
- [ ] Выполните задания 1,2,3 ниже

## Задание 1
Реализуйте класс бинарного дерева поиска.
Описание бинарного дерева поиска можно найти в книге Кормена "Алгоритмы. Построение и анализ (3-е издание)", стр 319, глава 12. Методы класса описаны ниже.

```cpp
template <class T>
class Tree {
public:
  struct Node {
    Node* Left;
    Node* Right;
    T Value;
  };

  BinarySearchTree();
  ~BinarySearchTree();

  void Add(const T&);
  Node* Find(const T&);
  void Remove(Node*);
};
```

## Задание 2
Реализовать функцию обхода с выводом бинарного дерева поиска
  N % 4 = x <br>
  Выберите ваш метод обхода дерева для своего x:
- 0 - **Обход в ширину** 
- 1 - **Прямой обход (preorder)**
- 2 - **Поперечный обход (inorder)**
- 3 - **Обратный обход (postorder)**

```cpp
void <название вашего обхода>(Node* root) {
```

## Задание 3

Реализуйте кастомную функцию согласно вашему варианту: 
N % 8 = х


1. Реализуйте функцию, которая проверяет является ли произвольное  бинарное дерево бинарным деревом поиска

```cpp
template <class T>
bool IsBinarySearchTree(Node<T>* root);
```

2. Реализуйте метод, который возвращает k-й наименьший элемент в BST

```cpp
template <class T>
T kthSmallest(T k);
```

3. Сериализация и десериализация<br>
	а. Реализуйте метод `string serialize()`, преобразующий дерево в строку, вставляя символ N вместо отсутствующих узлов
	**Пример**:  
	```
	     5
	    / \
	   3   7
	      /
	     6
	```
	→ `"5,3,7,N,N,6,N"`.<br>
	б. Напишите метод `void deserialize(const string& data)`, восстанавливающий BST из строки (формат как выше)


4. Слияние двух BST

**Условие**: Реализуйте метод `void merge(Tree& other)`, который объединяет текущее дерево с другим BST (используйте обходы inorder и слияние массивов). <br> 
**Сложность**: Оптимизируйте до O(n + m)


5. Поиск медианы в BST

**Условие**: Напишите метод `T median()`, находящий медиану (средний элемент) для BST с нечётным числом узлов.  <br>
**Оптимизация**: Используйте метод двух указателей без полного обхода.


6. Подсчёт узлов на каждом уровне<br>
**Условие**: Напишите метод `vector<T> countNodesPerLevel()`, возвращающий массив, где i-й элемент — число узлов на уровне i.  <br>
**Пример**:  
Для дерева:
```
      10
     /  \
    5    15
   /    /
  2    12
```
Результат: `[1, 2, 2]`.


7. Проверка на сбалансированность

**Условие**: Напишите метод `bool isBalanced()`, который возвращает `true`, если разница высот поддеревьев любого узла ≤ 1 (как в AVL-дереве).

8. Преобразование в "зеркальное" дерево

**Условие**: Напишите метод `void mirror()`, который отражает дерево горизонтально (левый и правый потомки меняются местами).  <br>
**Проверка**: После отражения inorder-обход должен дать обратно отсортированную последовательность.
